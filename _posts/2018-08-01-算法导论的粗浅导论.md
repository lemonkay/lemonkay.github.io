---
    layout: post
    title: ç®—æ³•å¯¼è®ºçš„ç²—æµ…å¯¼è®º
---

## 1. æ¸è¿›ç¬¦å·çš„å®šä¹‰

- ä¸Šé™å¤§ O çš„æ•°å­¦å®šä¹‰
  > å¯¹äº f(n) = O(g(n))ï¼Œè¡¨ç¤ºå­˜åœ¨é€‚å½“çš„å¸¸æ•° c>0,n0>0ï¼Œä½¿å¾— f(n) â‰¤ cÂ·g(n)ï¼Œå¯¹äºæ‰€æœ‰çš„ nâ‰¥n0
  > f(n)å¯ä»¥è¯´æ˜¯å±äº g(n)æ„æˆçš„å‡½æ•°é›†ï¼Œå¯ä»¥å®šä¹‰ O(g(n))ä¸ºä¸€ä¸ªå‡½æ•°é›† O(g(n)) = { f(n)ï¼šå­˜åœ¨ c>0ã€n0>0ï¼Œä½¿å¾— 0â‰¤f(n)â‰¤cg(n)ï¼Œå…¶ä¸­ nâ‰¥n0 }

## 2. æ’å…¥æ’åºï¼Œå½’å¹¶æ’åº

- insert sort: ä¸¤å±‚å¾ªç¯å°† key æ’å…¥æ’å¥½åºçš„ array ä¸­ï¼Œf(n)=n+(n-1)+(n-2)+...+1=Î˜(n^2)

  ```java
   /**
   * This method implements the Generic Insertion Sort
   *
   * @param array The array to be sorted
   * @param last The count of total number of elements in array
   * Sorts the array in increasing order
   **/

  public static <T extends Comparable<T>> void IS(T array[], int last) {
      T key;
      for (int j=1;j<last;j++) {

          // Picking up the key(Card)
          key = array[j];
          int i = j-1;
          while (i>=0 && key.compareTo(array[i]) < 0) {
              array[i+1] = array[i];
              i--;
          }
          // Placing the key (Card) at its correct position in the sorted subarray
          array[i+1] = key;
      }
  }
  ```

* merge sort:é€’å½’åœ°åˆå¹¶ä¸¤ä¸ªæ’åºå¥½çš„ arrayï¼Œf(n)=2f(n/2)+n=Î˜(nlgn)

  ```java
   /**
   * This method implements the Generic Merge Sort
   *
   * @param arr The array to be sorted
   * @param temp The copy of the actual array
   * @param left The first index of the array
   * @param right The last index of the array
   * Recursively sorts the array in increasing order
   **/

  public static <T extends Comparable<T>> void MS(T[] arr, T[] temp, int left, int right) {
      if (left < right) {
          int mid = left + (right - left) / 2;
          MS(arr, temp, left, mid);
          MS(arr,  temp,mid + 1, right);
          merge(arr, temp, left, mid, right);
      }

  }
  ```

  ```java
  /**
   * This method implements the merge step of the merge sort
   *
   * @param arr The array to be sorted
   * @param temp The copy of the actual array
   * @param left The first index of the array
   * @param mid The middle index of the array
   * @param right The last index of the array
   * merges two parts of an array in increasing order
   **/

  public static <T extends Comparable<T>> void merge(T[] arr, T[] temp, int left, int mid, int right) {
      for (int i=left;i<=right;i++) {
          temp[i] = arr[i];
      }

      int i= left;
      int j = mid + 1;
      int k = left;

      while (i<=mid && j<=right) {
          if (temp[i].compareTo(temp[j]) <= 0) {
              arr[k] = temp[i];
              i++;
          }
          else {
              arr[k] = temp[j];
              j++;
          }
          k++;
      }

      while (i <= mid) {
          arr[k] = temp[i];
          i++;
          k++;
      }
  }
  ```

## 3. é€’å½’å¼çš„è§£æ³•ï¼š

- åˆç†çš„çŒœç»“æœï¼šç”¨æ›¿æ¢æ³•è¯æ˜
- é€’å½’æ ‘ï¼šéœ€è¦åŠ ä¸Šæ‰€ä»¥æ ‘èŠ‚ç‚¹çš„å€¼ï¼Œä¸»è¦æœ‰ä¸¤ä¸ªå› ç´ å½±å“ï¼Œæ ‘é«˜ hï¼Œé¡µèŠ‚ç‚¹æ•°é‡ leafs

  ![retree](/images/retree.png)

- ä¸»å®šç†ï¼šT(n) = aT(n/b)+f(n)
  ![mainÎœethod](/images/Mastermethod.png)

*  ä¸Šé¢ä¸‰ç§æ–¹æ³•å¯ä»¥äº’ç›¸æ˜ è¯

## 4. åˆ†æ²»æ³•ï¼š

åœ¨æ¯ä¸€å±‚é€’å½’ä¸Šéƒ½æœ‰ä¸‰ä¸ªæ­¥éª¤ï¼š

- åˆ†è§£ï¼šå°†åŸé—®é¢˜åˆ†è§£ä¸ºè‹¥å¹²ä¸ªè§„æ¨¡è¾ƒå°ï¼Œç›¸å¯¹ç‹¬ç«‹ï¼Œä¸åŸé—®é¢˜å½¢å¼ç›¸åŒçš„å­é—®é¢˜
- è§£å†³ï¼šè‹¥å­é—®é¢˜è§„æ¨¡è¾ƒå°ä¸”æ˜“äºè§£å†³æ—¶ï¼Œåˆ™ç›´æ¥è§£ã€‚å¦åˆ™ï¼Œé€’å½’åœ°è§£å†³å„å­é—®é¢˜ã€‚
- åˆå¹¶ï¼šå°†å„å­é—®é¢˜çš„è§£åˆå¹¶ä¸ºåŸé—®é¢˜çš„è§£ã€‚

  ä¸Šé¢çš„ merge sort å°±æ˜¯ä¸€ä¸ªç»å…¸çš„ä¾‹å­

## 5.  å¿«é€Ÿæ’åº

- é€‰æ‹©ä¸€ä¸ª pivot,

```java
 /**
     * This method implements the Generic Quick Sort
     *
     * @param array The array to be sorted
     * @param start The first index of an array
     * @param end The last index of an array
     * Sorts the array in increasing order
     **/

    public static <T extends Comparable<T>> void QS(T array[], int start, int end) {
        if (start < end) {
            int PIndex = partition(array, start, end);
            QS(array, start, PIndex - 1);
            QS(array, PIndex + 1, end);
        }
    }

    /**
     * This method finds the partition index for an array
     *
     * @param array The array to be sorted
     * @param start The first index of an array
     * @param end The last index of an array
     * Finds the partition index of an array
     **/

    public static <T extends Comparable<T>> int partition(T array[], int start, int end) {
        T pivot = array[end];
        int PIndex = start;
        for (int i=start;i<end;i++) {
            if (array[i].compareTo(pivot) <= 0) {
                swap(array, i, PIndex);
                PIndex++;
            }
        }
        swap(array, PIndex, end);
        return PIndex;
    }
```

```python
def quick_sort(arr, simulation=False):
    """ Quick sort
        Complexity: best O(n log(n)) avg O(n log(n)), worst O(N^2)
    """

    iteration = 0
    if simulation:
        print("iteration",iteration,":",*arr)
    arr, _ = quick_sort_recur(arr, 0, len(arr) - 1, iteration, simulation)
    return arr

def quick_sort_recur(arr, first, last, iteration, simulation):
    if first < last:
        pos = partition(arr, first, last)
        # Start our two recursive calls
        if simulation:
            iteration = iteration + 1
            print("iteration",iteration,":",*arr)

        _, iteration = quick_sort_recur(arr, first, pos - 1, iteration, simulation)
        _, iteration = quick_sort_recur(arr, pos + 1, last, iteration, simulation)

    return arr, iteration

def partition(arr, first, last):
    wall = first
    for pos in range(first, last):
        if arr[pos] < arr[last]:  # last is the pivot
            arr[pos], arr[wall] = arr[wall], arr[pos]
            wall += 1
    arr[wall], arr[last] = arr[last], arr[wall]
    return wall
```

## 6. è®¡æ•°æ’åºåŠåŸºæ•°æ’åº

- åƒå¿«æ’è¿™ç±»åŸºäºæ¯”è¾ƒçš„æ’åºï¼Œå¯ä»¥ä»¥å†³ç­–æ ‘çš„å½¢å¼è¯æ˜

  - æ¯ä¸ªèŠ‚ç‚¹æ˜¯æ¯”è¾ƒï¼Œå¶å­èŠ‚ç‚¹æ˜¯æ‰€ä»¥å¯èƒ½çš„ç»“æœï¼Œn çš„é˜¶ä¹˜ï¼Œæ»¡äºŒå‰æ ‘çš„é«˜åº¦ä¸º nlgn,è¿™å°±æ˜¯æ¯”è¾ƒæ’åºæœ€å¥½çš„æ—¶é—´å¤æ‚åº¦ã€‚
  - å†³ç­–æ ‘  
    ä¸€ä¸ªå†³ç­–æ ‘åŒ…å«ä¸‰ç§ç±»å‹çš„èŠ‚ç‚¹ï¼š
    - å†³ç­–èŠ‚ç‚¹ï¼šé€šå¸¸ç”¨çŸ©å½¢æ¡†æ¥è¡¨ç¤º
    - æœºä¼šèŠ‚ç‚¹ï¼šé€šå¸¸ç”¨åœ†åœˆæ¥è¡¨ç¤º
    - ç»ˆç»“ç‚¹ï¼šé€šå¸¸ç”¨ä¸‰è§’å½¢æ¥è¡¨ç¤º
      ![decision_tree](/images/Decision-Tree.png)

- è®¡æ•°æ’åºï¼šå½“è¾“å…¥çš„å…ƒç´ æ˜¯ n ä¸ª 0 ï½ k çš„æ•´æ•°æ—¶ï¼ŒT(n)=Î˜(n+k)ï¼Œæ˜¯ç¨³å®šçš„çº¿æ€§æ’åºç®—æ³•

- åŸºæ•°æ’åºï¼šæŒ‰ä½åˆ†éš”ï¼Œæ¯ä¸€éƒ¨åˆ†å¯ä»¥é‡‡ç”¨è®¡æ•°æ’åº,å¯ä»¥ç”¨å½’çº³æ³•è¯æ˜.åŸºæ•°æ’åºçš„ T(n)=Î˜(n\*k),k æ˜¯æ•°å­—ä½æ•°

## 7. é¡ºåºç»Ÿè®¡å’Œä¸­å€¼

- æœ‰ä¸€ç³»åˆ—çš„å…ƒç´  n åœ¨æ•°ç»„ä¸­ï¼ˆæ— åºï¼‰ï¼Œå¸Œæœ›æ‰¾åˆ°ç¬¬ k å°çš„æ•°

  - éšæœºåˆ†æ²»ç®—æ³•
  ```c
  if p=q then
  return A[p]
  r = random-select(A, p, q)       | å¿«é€Ÿæ’åºçš„æ–¹æ³•
  k = r-p+1                        | åˆ’åˆ†å…ƒç´ çš„åºå·
  if i=k then return A[r]
  if i<k then
      return random-select(A, p, r-1, i)
  if i>k then
      return ramdom-select(A, r-1, q, i)
  ```
  - æœ€å·®æƒ…å†µï¼ŒT(n)=T(n-1)+c\*n;

  - ä¸ºäº†æ¶ˆé™¤ç†è®ºä¸Šçš„æœ€å·®æƒ…å†µ
    ![partition](/images/privot.png)

## 8. å“ˆå¸Œè¡¨
- hashå‡½æ•°çš„é€‰æ‹©ä¸€èˆ¬å¯ä»¥é€‰æ‹©ä¹˜æ³•
- hashç¢°æ’è§£å†³æ–¹å¼
    * é“¾è¡¨æ³•ï¼šè§java HashMapçš„å®ç°ï¼Œjdk1.7
    * å¼€æ”¾å¯»å€æ³•ï¼š hashFun(key,index)ï¼›æ€æƒ³æ˜¯ï¼šå‘ç”Ÿå†²çªæ—¶ï¼Œåœ¨æ¡¶ä¸­å¯»æ‰¾ä¸‹ä¸€ä¸ªå¯ç”¨çš„ä½ç½®
- å…¨åŸŸå“ˆå¸Œï¼šä¸ºäº†ä¿è¯å¯¹ç‰¹æ®Šè¾“å…¥çš„æ˜ å°„ï¼Œå¯éšæœºé€‰æ‹©hashå‡½æ•°ï¼ˆä¸æ˜¯æ¯æ¬¡æ“ä½œæ—¶éšæœºé€‰æ‹©ï¼Œæ˜¯æ„é€ å“ˆå¸Œè¡¨æ—¶éšæœºé€‰æ‹©ï¼‰
- å®Œç¾å“ˆå¸Œï¼šç”¨å…¨åŸŸå“ˆå¸Œ ä¸¤çº§æ„é€ å“ˆå¸Œè¡¨

## 9. äºŒå‰æœç´¢æ ‘ï¼Œbst
- bstçš„ç®—æ³•åˆ†æå¯ä»¥è·Ÿquick-sortç±»æ¯”ï¼Œä¹Ÿå¯ä»¥éšæœºåŒ–åœ°æ„å»ºbst

## 10. çº¢é»‘æ ‘ï¼Œblack-red tree

- ç®—æ³•åˆ†æå¯ä»¥ï¼Œå°†red nodeåˆåˆ°blackçš„p nodeä¸­ï¼Œå°±æ˜¯2-3-4-treeï¼Œå¯ä»¥åˆ†æå‡ºhight=log nï¼›

- è¿™è¾¹æ˜¯æ‹¿äº†HashMapä¸­çš„çº¢é»‘æ ‘çš„æ’å…¥ï¼Œrb insertï¼Œä¸»è¦æ˜¯é‡æ–°ç€è‰²ï¼Œå’Œæ ‘æ—‹è½¬æ“ä½œ
```java
 static <K,V> TreeNode<K,V> rotateRight(TreeNode<K,V> root,
                                               TreeNode<K,V> p) {
            TreeNode<K,V> l, pp, lr;
            if (p != null && (l = p.left) != null) {
                if ((lr = p.left = l.right) != null)
                    lr.parent = p;
                if ((pp = l.parent = p.parent 5 == null)
                    (root = l).red = false;
                else if (pp.right == p)
                    pp.right = l;
                else
                    pp.left = l;
                l.right = p;
                p.parent = l;
            }
            return root;
        }

        static <K,V> TreeNode<K,V> balanceInsertion(TreeNode<K,V> root,
                                                    TreeNode<K,V> x) {
            x.red = true;
            for (TreeNode<K,V> xp, xpp, xppl, xppr;;) {
                if ((xp = x.parent) == null) {
                    x.red = false;
                    return x;
                }
                else if (!xp.red || (xpp = xp.parent) == null)
                    return root;
                if (xp == (xppl = xpp.left)) {
                    //case1:xppr ä¸º red
                    if ((xppr = xpp.right) != null && xppr.red) {
                        xppr.red = false;
                        xp.red = false;
                        xpp.red = true;
                        x = xpp;
                    }
                    else {
                        //case2ï¼šx,xp,xppä¸åœ¨ä¸€ä¸ªç›´çº¿ä¸Š,xpæ—‹è½¬åˆ°åŒä¸€æ¡ç›´çº¿ï¼Œåˆ°case3
                        if (x == xp.right) {
                            root = rotateLeft(root, x = xp);
                            xpp = (xp = x.parent) == null ? null : xp.parent;
                        }
                        //case3:xppæ—‹è½¬ï¼Œé‡æ–°ç€è‰²
                        if (xp != null) {
                            xp.red = false;
                            if (xpp != null) {
                                xpp.red = true;
                                root = rotateRight(root, xpp);
                            }
                        }
                    }
                }
                else {
                    if (xppl != null && xppl.red) {
                        xppl.red = false;
                        xp.red = false;
                        xpp.red = true;
                        x = xpp;
                    }
                    else {
                        if (x == xp.left) {
                            root = rotateRight(root, x = xp);
                            xpp = (xp = x.parent) == null ? null : xp.parent;
                        }
                        if (xp != null) {
                            xp.red = false;
                            if (xpp != null) {
                                xpp.red = true;
                                root = rotateLeft(root, xpp);
                            }
                        }
                    }i
                }
            }
        }
```
- [wikiä¸­å®šä¹‰çš„æ ‘æ—‹è½¬](https://zh.wikipedia.org/wiki/%E6%A0%91%E6%97%8B%E8%BD%AC) ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯è¿™è¾¹ rotateLeft(root, x = xp)ï¼Œpivotæ˜¯å¤´ï¼Œå·¦æ—‹å°±æ˜¯ç”©å·¦è†€å­ï¼Œç„¶åç”©åˆ°è‡ªå·±å¤´ä¸Šäº†ï¼ŒğŸ˜¢

## 11. åŠ¨æ€æœ‰åºç»Ÿè®¡å’ŒåŒºé—´æ ‘
- åŠ¨æ€æœ‰åºç»Ÿè®¡
    * åœ¨çº¢é»‘æ ‘çš„nodeä¸­,æ·»åŠ å­æ ‘sizeï¼ˆsizeOf(left)+sizeOf(right)+1ï¼‰ï¼Œï¼ˆä¸æ˜¯rankå€¼ï¼Œæ˜¯ä¿®æ”¹æ ‘æ—¶å¿«æ·ï¼‰
- æ•°æ®ç»“æ„çš„æ‰©å±•èŒƒå¼
    1. é€‰å®šä¸€ä¸ªç°æœ‰åŸºæœ¬çš„æ•°æ®ç»“æ„ï¼ˆæ¯”å¦‚çº¢é»‘æ ‘ï¼‰
    2. æ·»åŠ æ‰©å±•ä¿¡æ¯ï¼ˆnode add childTree sizeï¼‰
    3. éªŒè¯åŸæœ‰æ•°æ®ç»“æ„åŠŸèƒ½çš„æ­£ç¡®æ€§
    4. éªŒè¯æ·»åŠ åŠŸèƒ½çš„æ­£ç¡®æ€§

- åŒºé—´æ ‘
    * ä¹Ÿå¯ä»¥ä»¥çº¢é»‘æ ‘ä¸ºåŸºç¡€ï¼Œnodeçš„valueæ˜¯åŒºé—´çš„æœ€å°ç«¯ï¼ˆbstçš„åˆ¤æ–­å€¼ï¼‰ï¼Œé¢å¤–ä¿¡æ¯æ˜¯åŒºé—´æœ€å¤§ç«¯rå€¼ï¼Œå’Œ m=max(lefTree.m,rightTree.m,r)å€¼
    * code:åœ¨ä¸€ä¸ªwhileå¾ªç¯ä¸­åˆ¤æ–­è¾“å…¥åŒºé—´ æ˜¯å¦è·ŸnodeåŒºé—´æ˜¯å¦æœ‰äº¤é›†ï¼Œå¦‚æœæ²¡æœ‰ï¼Œåˆ°å­æ ‘å»éå†ã€‚è¿˜æœ‰ä¸€ä¸ªæ¡ä»¶æ˜¯åˆ¤æ–­æ˜¯left or right
    * å½“éœ€è¦æŸ¥æ‰¾å¤šä¸ªæ—¶ï¼Œå¯ä»¥select->delete->select->

## 12.å¹³æ‘Šåˆ†æ,è®°è´¦&åŠ¿èƒ½æ–¹æ³•
- å“ˆå¸Œè¡¨çš„æ‰©å®¹ï¼ˆå¦‚é“¾è¡¨æ³•ï¼Œä¸ºäº†å¹³è¡¡æ—¶é—´å’Œç©ºé—´ï¼Œå“ˆå¸Œè¡¨éœ€è¦åŠ¨æ€æ‰©å®¹ï¼‰ï¼Œfor exampleï¼Œåœ¨javaä¸­çš„HashMap,resizeçš„é˜ˆå€¼æ˜¯è´Ÿè½½å› å­è¾¾åˆ°0.75ï¼Œå€æ•°æ˜¯double
- nä¸ªå…ƒç´ çš„å“ˆå¸Œè¡¨æ„å»ºï¼Œæ’å…¥ä»£ä»·ï¼šnï¼›æ‰©å®¹çš„ä»£ä»·ï¼šlg n æ¬¡j
- è®°è´¦ï¼šè®¾ç½®ä¸€ä¸ªbank accountï¼Œé™å®šå€¼æ˜¯ balance>=0ã€‚æ¯æ¬¡æ’å…¥å­˜3å»1ä½™2ï¼Œæ‰©å®¹æ—¶å–å‡ºæ‰€æœ‰å­˜æ¬¾
- åŠ¿èƒ½: ç¬¬i æ¬¡æ“ä½œåŠ¿èƒ½å‡½æ•°ï¼šF(i)=2i-2^logi;åŒæ ·çš„é™å®šå€¼æ˜¯F(i)>=0  
       å¹³æ‘Šä»£ä»·ï¼šc^(i)=c(i)+F(i)-F(i-1);åˆ™æ€»çš„c^(t)=c(t)+F(max)-F(0)ï¼Œè®¾å®šF(0)=0,F(i)>0,æ•…æ­¤æ—¶å¹³æ‘Šä»£ä»·æ˜¯å®é™…ä»£ä»·çš„ä¸€ä¸ªä¸Šé™

## 13. è‡ªç»„ç»‡è¡¨çš„ç«äº‰åˆ†æ
- è‡ªç»„ç»‡è¡¨ï¼š
    - å®šä¹‰ä¸¤ç§æ“ä½œ
    1. nä¸ªå…ƒç´ çš„åˆ—è¡¨Lï¼Œè®¿é—®ï¼ˆå¯èƒ½æ˜¯æŸ¥æ‰¾ï¼Œä¹Ÿå¯ä»¥æ˜¯å…¶ä»–æ“ä½œï¼‰å…ƒç´ xçš„ä»£ä»·ä¸å…ƒç´ åœ¨åˆ—è¡¨ä¸­çš„ä½ç½®æœ‰å…³ï¼ˆä»è¡¨å¤´åˆ°xçš„è·ç¦»ï¼‰ã€‚
    2. å…ƒç´ åœ¨Lä¸­çš„ä½ç½®å¯ä»¥é€šè¿‡äº¤æ¢ç›¸é‚»çš„å…ƒç´ æ¥æ”¹å˜ï¼Œè€Œè¿™ä¸ªæ“ä½œçš„ä»£ä»·ä¸ºO(1)ã€‚
    
    - ä¸€ä¸ªæ“ä½œåºåˆ—ï¼Œæ¯æ¬¡åªå‘é€ä¸€æ¬¡æ“ä½œè¯·æ±‚ã€‚
        1. åœ¨çº¿ç®—æ³•ï¼ˆonlineï¼‰ï¼šå¿…é¡»ç«‹å³å®Œæˆè¿™æ­¥æ“ä½œï¼Œè€Œä¸ç®¡ä¹‹åçš„æ“ä½œæ˜¯ä»€ä¹ˆï¼ˆå³ä¸èƒ½é¢„çŸ¥åç»­æ“ä½œï¼‰ã€‚
        2. ç¦»çº¿ç®—æ³•ï¼ˆofflineï¼‰ï¼šç¦»çº¿ç®—æ³•å¯ä»¥å‡è®¾å¯ä»¥é¢„è¯»æ•´ä¸ªåºåˆ—ï¼Œä»è€Œå¯ä»¥å¯¹æ•´ä¸ªæ“ä½œåºåˆ—åšä¼˜åŒ–ã€‚

    - ç«äº‰åˆ†æ
        * ä¸€ä¸ªåœ¨çº¿ç®—æ³•Aæ˜¯aç«äº‰çš„:å¦‚æœå­˜åœ¨ä¸€ä¸ªå¸¸æ•°kï¼Œæ»¡è¶³å¯¹äºä»»ä½•çš„æ“ä½œåºåˆ—Sï¼Œæ»¡è¶³  
            CAï¼ˆSï¼‰<=a*Copt(S) + k
            å³ï¼Œç®—æ³•Aå¯¹Sçš„æ“ä½œä»£ä»·ä¸å¤§äºå…¶æœ€ä¼˜çš„ç¦»çº¿ç®—æ³•ä¹˜ä¸Šaï¼Œå†åŠ kã€‚

    - MTF(move to front),æ¯æ¬¡è®¿é—®åˆ°å°†å…ƒç´ xç½®æ¢åˆ°è¡¨å¤´ï¼Œæ˜¯4ç«äº‰çš„

## 14.åŠ¨æ€è§„åˆ’å’Œæœ€é•¿å…¬å…±åºåˆ—
- åŠ¨æ€è§„åˆ’ï¼ˆè‹±è¯­ï¼šDynamic programmingï¼Œç®€ç§°DPï¼‰é€šè¿‡æŠŠåŸé—®é¢˜åˆ†è§£ä¸ºç›¸å¯¹ç®€å•çš„å­é—®é¢˜çš„æ–¹å¼æ±‚è§£å¤æ‚é—®é¢˜çš„æ–¹æ³•ã€‚åŠ¨æ€è§„åˆ’æ–¹æ³•æ‰€è€—æ—¶é—´å¾€å¾€è¿œå°‘äºæœ´ç´ è§£æ³•ã€‚
    * æœ€ä¼˜å­ç»“æ„æ€§è´¨ã€‚å¦‚æœé—®é¢˜çš„æœ€ä¼˜è§£æ‰€åŒ…å«çš„å­é—®é¢˜çš„è§£ä¹Ÿæ˜¯æœ€ä¼˜çš„,æˆ‘ä»¬å°±ç§°è¯¥é—®é¢˜å…·æœ‰æœ€ä¼˜å­ç»“æ„æ€§è´¨ï¼ˆå³æ»¡è¶³æœ€ä¼˜åŒ–åŸç†ï¼‰ã€‚ï¼ˆå¯ç”¨å‰ªåˆ‡æ³•åè¯ï¼‰
    * å­é—®é¢˜é‡å æ€§è´¨ã€‚å­é—®é¢˜é‡å æ€§è´¨æ˜¯æŒ‡åœ¨ç”¨é€’å½’ç®—æ³•è‡ªé¡¶å‘ä¸‹å¯¹é—®é¢˜è¿›è¡Œæ±‚è§£æ—¶ï¼Œæ¯æ¬¡äº§ç”Ÿçš„å­é—®é¢˜å¹¶ä¸æ€»æ˜¯æ–°é—®é¢˜ï¼Œæœ‰äº›å­é—®é¢˜ä¼šè¢«é‡å¤è®¡ç®—å¤šæ¬¡ã€‚(å¤‡å¿˜æ³•,ä¿å­˜å­é—®é¢˜çš„è§£)

## 15.å›¾ç®—æ³•ï¼ˆæœ€çŸ­è·¯å¾„é—®é¢˜ï¼‰
- å•æºæœ€çŸ­è·¯å¾„ Dijkstraç®—æ³•ï¼ˆé‚»æ¥è¡¨/é‚»æ¥çŸ©é˜µ+ä¼˜å…ˆé˜Ÿåˆ—STL) 
    * ä¼ªä»£ç 
        ```python
        1  function Dijkstra(Graph, source):
        2      dist[source] â† 0                           // Initialization
        3
        4      create vertex set Q
        5
        6      for each vertex v in Graph:           
        7          if v â‰  source
        8              dist[v] â† INFINITY                 // Unknown distance from source to v
        9          prev[v] â† UNDEFINED                    // Predecessor of v
        10
        11         Q.add_with_priority(v, dist[v])
        12
        13
        14     while Q is not empty:                      // The main loop
        15         u â† Q.extract_min()                    // Remove and return best vertex
        16         for each neighbor v of u:              // only v that are still in Q
        17             alt â† dist[u] + length(u, v) 
        18             if alt < dist[v]
        19                 dist[v] â† alt
        20                 prev[v] â† u
        21                 Q.decrease_priority(v, alt)
        22
        23     return dist, prev

        ```
    * detail:ä¼˜å…ˆçº§é˜Ÿåˆ—çš„å®ç°

    * link ä¸€äº›è”æƒ³
        1. å›¾çš„å¹¿åº¦ä¼˜å…ˆæœç´¢(BFS) å°±æ˜¯ Dijkstraç®—æ³•ä¸€ä¸ªç‰¹æ®Šcase ï¼Œå°†ä¼˜å…ˆé˜Ÿåˆ—æ”¹ä¸ºæ™®é€šé˜Ÿåˆ—ï¼Œè¾¹çš„æƒé‡éƒ½ä¸º1
        2. è€ŒäºŒå‰æ ‘çš„å±‚æ¬¡éå†åˆæ˜¯ BFS çš„ç‰¹æ®Šcase 

- Bellmanâ€“Fordç®—æ³•ï¼ˆæ”¯æŒè´Ÿæƒé‡å’Œè´Ÿç¯è·¯çš„æ£€æµ‹ï¼‰
    * code  

    ```python 
    function BellmanFord(list vertices, list edges, vertex source)
        ::distance[],predecessor[]
        
        // This implementation takes in a graph, represented as
        // lists of vertices and edges, and fills two arrays
        // (distance and predecessor) about the shortest path
        // from the source to each vertex
        
        // Step 1: initialize graph
        for each vertex v in vertices:
            distance[v] := inf             // Initialize the distance to all vertices to infinity
            predecessor[v] := null         // And having a null predecessor
        
        distance[source] := 0              // The distance from the source to itself is, of course, zero
        
        // Step 2: relax edges repeatedly
        for i from 1 to size(vertices)-1:
            for each edge (u, v) with weight w in edges:
                if distance[u] + w < distance[v]:
                    distance[v] := distance[u] + w
                    predecessor[v] := u
        
        // Step 3: check for negative-weight cycles
        for each edge (u, v) with weight w in edges:
            if distance[u] + w < distance[v]:
                error "Graph contains a negative-weight cycle"
        
        return distance[], predecessor[]

    ```
    * ç®€å•åˆ†æï¼šæ¯ä¸€æ¬¡å¾ªç¯ï¼Œè‚¯å®šæ˜¯ä»æºé¡¶ç‚¹s,å‘ä¸‹æ¾å¼›äº†ä¸€æ­¥ï¼Œv1->v2->v3->â€¦â€¦vk,æ‰€ä»¥size(v)-1 æ¬¡è‚¯å®šæ¾å¼›äº†æ‰€æœ‰çš„e

- çº¿æ€§è§„åˆ’å’Œå·®åˆ†çº¦æŸ
    * çº¿æ€§è§„åˆ’ï¼š
        - æè¿°çº¿æ€§è§„åˆ’é—®é¢˜çš„å¸¸ç”¨å’Œæœ€ç›´è§‚å½¢å¼æ˜¯æ ‡å‡†å‹ã€‚æ ‡å‡†å‹åŒ…æ‹¬ä»¥ä¸‹ä¸‰ä¸ªéƒ¨åˆ†ï¼š
            1. ä¸€ä¸ªéœ€è¦æå¤§åŒ–çš„çº¿æ€§å‡½æ•°ï¼Œä¾‹å¦‚  
            $c_1 x_1 + c_2 x_2$

            2. ä»¥ä¸‹å½¢å¼çš„é—®é¢˜çº¦æŸï¼Œä¾‹å¦‚ï¼š  
            $a_{11} x_1 + a_{12} x_2 \le b_1$  
            $a_{21} x_1 + a_{22} x_2  \le b_2$
            $a_{31} x_1 + a_{32} x_2  \le b_3$
            3. å’Œéè´Ÿå˜é‡ï¼Œä¾‹å¦‚:   
            $x_1 \ge 0$  
            $x_2 \ge 0$

        - çº¿æ€§è§„åˆ’é—®é¢˜é€šå¸¸å¯ä»¥ç”¨çŸ©é˜µå½¢å¼è¡¨è¾¾æˆï¼š  
        $maximize {\displaystyle \mathbf {c} ^{T}\mathbf {x} } \mathbf{c}^T \mathbf{x}$  
        $subject to {\displaystyle \mathbf {A} \mathbf {x} \leq \mathbf {b} ,\,\mathbf {x} \geq 0} \mathbf{A}\mathbf{x} \le \mathbf{b}, \, \mathbf{x} \ge 0$
    


        
    * å·®åˆ†çº¦æŸï¼šXi-Xj< s,å¯ä»¥æ˜ å°„åˆ°å›¾çš„G(V,E),V(Xi)--w=s-->V(Xj),è¿™ä¸ªå›¾ç§°ä¸ºçº¦æŸå›¾

- å…¨å¯¹æœ€çŸ­è·¯å¾„
    * 


## 16.å¹¶è¡Œç®—æ³•
- è®¡ç®—ç¬¬nä¸ªæ–æ³¢æ‹‰å¥‘æ•°çš„æ¨¡å‹ã€‚ä¼ªç¨‹åºï¼ˆpseudocodeï¼‰ä»£ç å¦‚å›¾æ‰€ç¤ºï¼š
    * ![å¹¶è¡Œè®¡ç®—ä¼ªä»£ç ](/images/parallel_model.png)
    * è¡ç”ŸSpwanï¼šå­ç¨‹åºï¼ˆsubroutineï¼‰å¯ä»¥å’Œçˆ¶ç¨‹åºä¸€èµ·æ‰§è¡Œã€‚æ¯”å¦‚ç¨‹åºæ‰§è¡Œåˆ°Fib(n-1),ä¼šäº§ç”Ÿå­ç¨‹åºçš„åŒæ—¶ä¹Ÿä¼šæ‰§è¡Œä¸‹ä¸€å¥Fib(n-2)ã€‚
    * åŒæ­¥Syncï¼šç­‰å¾…æ‰€æœ‰å­ç¨‹åºå®Œæˆã€‚å¿…é¡»ç­‰åˆ°æ‰€æœ‰xå’Œyéƒ½è®¡ç®—å‡ºæ¥ï¼Œæ‰èƒ½è®¡ç®—x-yã€‚

- å®šä¹‰ä¸€äº›å˜é‡ï¼š
    * Tp = åœ¨Pä¸ªå¤„ç†å™¨ä¸Šçš„è¿è¡Œæ—¶é—´ï¼ˆrunningtimeï¼‰
    * T_âˆ= å…³é”®è·¯å¾„é•¿åº¦ï¼ˆthecritical pathlengthï¼‰ï¼ŒDAGä¸­æœ€é•¿çš„è·¯å¾„ã€‚å³å¤„ç†å™¨æœ‰æ— æ•°å¤šä¸ªï¼Œè¿è¡Œç¨‹åºæ‰€ç”¨çš„æ—¶é—´ã€‚
    * T1 = ä¸€ä¸ªå¤„ç†å™¨ä¸Šè¿è¡Œçš„æ—¶é—´ï¼Œå³ä¸ºä¸²è¡Œè¿è¡Œæ—¶é—´ï¼ˆtheserial timeï¼‰ã€‚ä¸€ä¸ªçº¿ç¨‹åœ¨ä¸€ä¸ªå¤„ç†å™¨ä¸Šè¿è¡Œçš„æ—¶é—´ç§°ä¸ºåŠŸ(work)ã€‚

- å®šç†åŠæ¨è®º
    * Tp>=T1/P   Tp>=T_âˆ
    * ä¸€ä¸ªè´ªå©ªè°ƒåº¦ç®—æ³•(Greedyscheduler)æ‰§è¡Œä»»æ„è®¡ç®—DAG Gï¼Œè‹¥åŠŸä¸ºT1,å…³é”®è·¯å¾„é•¿ä¸ºT_âˆ ï¼Œé‚£ä¹ˆå®ƒçš„è¿è¡Œæ—¶é—´Tp=< T1/P + T_âˆ
    * å¹¶è¡Œåº¦ p = T1/T_âˆ

 





