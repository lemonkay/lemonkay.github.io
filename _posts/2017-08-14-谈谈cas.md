---
ã€€ã€€layout: default
ã€€ã€€title: cas
---
### è°ˆè°ˆcas(ä¸»è¦æ˜¯é˜¿é‡Œç”µé¢å›ç­”ä¸å¦¥,ğŸ˜¢)

Compare- and- Swap
> CASæŒ‡ä»¤éœ€è¦æœ‰3ä¸ªæ“ä½œæ•°ï¼Œåˆ†åˆ«æ˜¯å†…å­˜ä½ç½®ï¼ˆåœ¨Javaä¸­å¯ä»¥ç®€å•ç†è§£ä¸ºå˜é‡çš„å†…å­˜åœ°å€ï¼Œç”¨Vè¡¨ç¤ºï¼‰ã€æ—§çš„é¢„æœŸå€¼ï¼ˆç”¨Aè¡¨ç¤ºï¼‰å’Œæ–°å€¼ï¼ˆç”¨Bè¡¨ç¤ºï¼‰ã€‚CASæŒ‡ä»¤æ‰§è¡Œæ—¶ï¼Œå½“ä¸”ä»…å½“Vç¬¦åˆæ—§é¢„æœŸå€¼Aæ—¶ï¼Œå¤„ç†å™¨ç”¨æ–°å€¼Bæ›´æ–°Vçš„å€¼ï¼Œå¦åˆ™å®ƒå°±ä¸æ‰§è¡Œæ›´æ–°ï¼Œä½†æ˜¯æ— è®ºæ˜¯å¦æ›´æ–°äº†Vçš„å€¼ï¼Œéƒ½ä¼šè¿”å›Vçš„æ—§å€¼ï¼Œä¸Šè¿°çš„å¤„ç†è¿‡ç¨‹æ˜¯ä¸€ä¸ªåŸå­æ“ä½œã€‚ 
> 
> å¦‚æœä¸€ä¸ªå˜é‡Våˆæ¬¡è¯»å–çš„æ—¶å€™æ˜¯Aå€¼ï¼Œå¹¶ä¸”åœ¨å‡†å¤‡èµ‹å€¼çš„æ—¶å€™æ£€æŸ¥åˆ°å®ƒä»ç„¶ä¸ºAå€¼ï¼Œé‚£æˆ‘ä»¬å°±èƒ½è¯´å®ƒçš„å€¼æ²¡æœ‰è¢«å…¶ä»–çº¿ç¨‹æ”¹å˜è¿‡äº†å—ï¼Ÿå¦‚æœåœ¨è¿™æ®µæœŸé—´å®ƒçš„å€¼æ›¾ç»è¢«æ”¹æˆäº†Bï¼Œåæ¥åˆè¢«æ”¹å›ä¸ºAï¼Œé‚£CASæ“ä½œå°±ä¼šè¯¯è®¤ä¸ºå®ƒä»æ¥æ²¡æœ‰è¢«æ”¹å˜è¿‡ã€‚è¿™ä¸ªæ¼æ´ç§°ä¸ºCASæ“ä½œçš„"ABA"é—®é¢˜ã€‚J.U.CåŒ…ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæä¾›äº†ä¸€ä¸ªå¸¦æœ‰æ ‡è®°çš„åŸå­å¼•ç”¨ç±»"AtomicStampedReference"ï¼Œå®ƒå¯ä»¥é€šè¿‡æ§åˆ¶å˜é‡å€¼çš„ç‰ˆæœ¬æ¥ä¿è¯CASçš„æ­£ç¡®æ€§ã€‚

1. ä¸Šè¿°çš„åŸç†ä¹Ÿæ˜¯ memcached add()ç¼“å­˜é”çš„å®ç°æœºåˆ¶ï¼›
2. redis é”å®šæ˜¯åˆ©ç”¨ setnxå‘½ä»¤ã€‚å³åªæœ‰åœ¨æŸä¸ªkeyä¸å­˜åœ¨çš„æƒ…å†µä¸‹æ‰èƒ½setæˆåŠŸè¯¥keyï¼Œè¿™æ ·å°±è¾¾åˆ°å¤šä¸ªçº¿ç¨‹å¹¶å‘å»setåŒä¸€ä¸ªkeyï¼Œåªæœ‰ä¸€ä¸ªèƒ½æˆåŠŸ


ä¸‹é¢æ¥çœ‹çœ‹memcached addæ–¹æ³•çš„å®ç°ä»£ç 

``` java
//è¿™ä¸ªasyncStoreæ–¹æ³•ï¼ŒåŒ¿åå†…éƒ¨ç±»
  private <T> OperationFuture<Boolean> asyncStore(StoreType storeType, String key, int exp, T value, Transcoder<T> tc) {
        CachedData co = tc.encode(value);
        final CountDownLatch latch = new CountDownLatch(1);
        final OperationFuture<Boolean> rv = new OperationFuture(key, latch, this.operationTimeout);
        //op æ˜¯ StoreOperation
        Operation op = this.opFact.store(storeType, key, co.getFlags(), exp, co.getData(), new Callback() {
            public void receivedStatus(OperationStatus val) {
                rv.set(val.isSuccess(), val);
            }

            public void gotData(String key, long cas) {
                rv.setCas(cas);
            }

            public void complete() {
                latch.countDown();
            }
        });
        rv.setOperation(op);
        this.mconn.enqueueOperation(key, op);
        return rv;
    }
    
```  

``` java
protected void addOperation(String key, Operation o) {
        MemcachedNode placeIn = null;
        MemcachedNode primary = this.locator.getPrimary(key);
        if (!primary.isActive() && this.failureMode != FailureMode.Retry) {
            if (this.failureMode == FailureMode.Cancel) {
                o.cancel();
            } else {
            //memcached ä¸­keyéƒ½ç»´æŠ¤äº†ä¸€ä¸ªçš„å¯¹åº”çš„nodeé˜Ÿåˆ—
                Iterator i = this.locator.getSequence(key);

                while(placeIn == null && i.hasNext()) {
                    MemcachedNode n = (MemcachedNode)i.next();
                    if (n.isActive()) {
                        placeIn = n;
                    }
                }

                if (placeIn == null) {
                    placeIn = primary;
                    this.getLogger().warn("Could not redistribute to another node, retrying primary node for %s.", new Object[]{key});
                }
            }
        } else {
            placeIn = primary;
        }

        assert o.isCancelled() || placeIn != null : "No node found for key " + key;

        if (placeIn != null) {
        //ç»è¿‡nodeéªŒè¯åï¼Œnodeæ·»åŠ ä¸»è¦æ˜¯è¿™ä¸ªæ–¹æ³•
            this.addOperation(placeIn, o);
        } else {
            assert o.isCancelled() : "No node found for " + key + " (and not immediately cancelled)";
        }
```


``` java 

protected void addOperation(MemcachedNode node, Operation o) {
        o.setHandlingNode(node);
        o.initialize();
        node.addOp(o);
        //addedQueueæ˜¯ConcurrentLinkedQueueè¿™ä¸ªçº¿ç¨‹å®‰å…¨çš„é“¾è¡¨å½¢å¼çš„é˜Ÿåˆ—
        this.addedQueue.offer(node);
        Selector s = this.selector.wakeup();

        assert s == this.selector : "Wakeup returned the wrong selector.";

        this.getLogger().debug("Added %s to %s", new Object[]{o, node});
    }
    
   // ConcurrentLinkedQueue offeræ–¹æ³•
     public boolean offer(E e) {
        checkNotNull(e);
        final Node<E> newNode = new Node<E>(e);

        for (Node<E> t = tail, p = t;;) {
            Node<E> q = p.next;
            if (q == null) {
                // p is last nodeã€‚ä¸”å½“p==null æ—¶ï¼Œæ‰ä¼šsetï¼Œå› ä¸ºæ—§çš„é¢„æœŸå€¼ä¸ºnull
                if (p.casNext(null, newNode)) {
                    // Successful CAS is the linearization point
                    // for e to become an element of this queue,
                    // and for newNode to become "live".
                    if (p != t) // hop two nodes at a time
                        casTail(t, newNode);  // Failure is OK.
                    return true;
                }
                // Lost CAS race to another thread; re-read next
            }
            else if (p == q)
                // We have fallen off list.  If tail is unchanged, it
                // will also be off-list, in which case we need to
                // jump to head, from which all live nodes are always
                // reachable.  Else the new tail is a better bet.
                p = (t != (t = tail)) ? t : head;
            else
                // Check for tail updates after two hops.
                p = (p != t && t != (t = tail)) ? t : q;
        }
    }
    
    //casNextæ–¹æ³• cas
     boolean casNext(Node<E> cmp, Node<E> val) {
            return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);
        }

//Unsafe çš„nativeæ–¹æ³•
 public final native boolean compareAndSwapObject(Object var1, long var2, Object var4, Object var5);
    
```    

æ¥è¯´è¯´ä¹è§‚é”ï¼š
> åŸºäºå†²çªæ£€æµ‹çš„ä¹è§‚å¹¶å‘ç­–ç•¥ï¼Œé€šä¿—åœ°è¯´ï¼Œå°±æ˜¯å…ˆè¿›è¡Œæ“ä½œï¼Œå¦‚æœæ²¡æœ‰å…¶ä»–çº¿ç¨‹äº‰ç”¨å…±äº«æ•°æ®ï¼Œé‚£æ“ä½œå°±æˆåŠŸäº†ï¼›å¦‚æœå…±äº«æ•°æ®æœ‰äº‰ç”¨ï¼Œäº§ç”Ÿäº†å†²çªï¼Œé‚£å°±å†é‡‡å–å…¶ä»–çš„è¡¥å¿æªæ–½ï¼ˆæœ€å¸¸è§çš„è¡¥å¿æªæ–½å°±æ˜¯ä¸æ–­åœ°é‡è¯•ï¼Œç›´åˆ°æˆåŠŸä¸ºæ­¢ï¼‰ï¼Œè¿™ç§ä¹è§‚çš„å¹¶å‘ç­–ç•¥çš„è®¸å¤šå®ç°éƒ½ä¸éœ€è¦æŠŠçº¿ç¨‹æŒ‚èµ·ï¼Œå› æ­¤è¿™ç§åŒæ­¥æ“ä½œç§°ä¸ºéé˜»å¡åŒæ­¥ï¼ˆNon-BlockingSynchronizationï¼‰ã€‚
 
å¯ä»¥ç”¨casæ¥è¿›è¡Œå†²çªæ£€æµ‹ï¼šä¸Šé¢çš„å°±æ˜¯conflictå°±æ˜¯å¿…é¡»ä¸ºnullï¼Œæ›´é€šç”¨çš„æ–¹å¼æ˜¯ä¸ºä¸ºæ¯æ¬¡æ“ä½œè®¾ç½® ç‰ˆæœ¬å·ï¼Œæœ¬æ¬¡æ“ä½œä¼šå¸¦ä¸€ä¸ªæœŸæœ›ä¸Šä¸€ä¸ªæ—§ç‰ˆæœ¬å·ï¼Œç„¶åè¿›è¡Œcasæ“ä½œï¼Œå¯¹æ¯”å½“å‰ç‰ˆæœ¬å·è·ŸæœŸæœ›æ˜¯å¦ä¸€è‡´ï¼Œä¸ä¸€è‡´å°±æ˜¯æœ‰å†²çªï¼Œæ“ä½œæ”¾å¼ƒ
   
    
    