---
    layout: post
    title: 项目中遇到的问题总结
---

1. 代扣任务中重复扣款的问题
    - 问题描述及原因：调用第三方代扣接口时，同步返回失败，因为同步接口失败（参数错误，余额不足）等前置错误原因是有意义的，不能统一等待异步结果。但这边渠道方已经处理成功。
    - 解决方案：要求下层代扣接口对同步错误做区分，渠道结果未知需单独给出；但接收到这种错误，需将代扣未知结果做数据持久化，任务进行查询确认，确实失败的话，提供重试机制。


2. http异步通知同一时间重复通知的情况，需要做分布式缓存锁（在一个公用的存储服务上排队），现接触到有两种方案：
    - 数据库的唯一键
    - redis或者memcache等缓存key值的设置
    - 用zk的node设置

3. 项目中一些积累
    - 收银台项目的支付渠道的配置化，并在业务流程中前置操作filter，execute，listener； 
    - 防止重复支付的问题，对交易单的请求 做redis lock,setNX方法，缓存需设置expire，防止资源的永久锁定
    - tcc一些事务的管理
    - 担保交易过程中的冻结，解冻操作
    - redis,memcache缓存使用
    - 用jstack 慢sql的定位，和数据库事务死锁
    - guava eventBus,cache


### 在网易这边遇到的坑
1. oracle于mybatis的结合
    - 如果在备库（只读库）中timestamp的是占位符的使用，需要把 `to_date(#{startTime},'yyyy-mm-dd hh24:mi:ss')` 这个写死，不然的话下面的错误
    - ORA-16000: database open for read-only access ---使用一些存储过程  或者Oracle 系统的函数  对数据库有编译操作

2. oracle的fetchsize，分批fetchsize会出现curse错位
    - 同一个jdbc连接会共享oracle的curse，[so](https://stackoverflow.com/questions/12192592/java-sql-sqlexception-ora-01000-maximum-open-cursors-exceeded)